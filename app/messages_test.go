package main

import (
	"fmt"
	"net"
	"testing"
	"time"
)

// quick test for createFetchRequestFromBytes

func TestCreateFetchRequestFromBytes(t *testing.T) {
	message := []byte{0x00, 0x01, 0x00, 0x10, 0x34, 0xea, 0x00, 0x8a, 0x00, 0x09, 0x6b, 0x61, 0x66, 0x6b, 0x61, 0x2d, 0x63, 0x6c, 0x69, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x00, 0x00, 0x00, 0x01, 0x03, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x52, 0x02, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00}

	fr := createFetchRequestFromBytes(message)
	// expect correlation_id to be 336430426
	if fr.correlation_id != 887750794 {
		t.Errorf("Expected correlation_id to be 336430426, got %d", fr.correlation_id)
	}
}

func TestCreateFetchResponseFromFetchRequest(t *testing.T) {
	message := []byte{0x00, 0x01, 0x00, 0x10, 0x4f, 0x68, 0xbf, 0x9e, 0x00, 0x09, 0x6b, 0x61, 0x66, 0x6b, 0x61, 0x2d, 0x63, 0x6c, 0x69, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x00, 0x00, 0x00, 0x01, 0x03, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x41, 0x02, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00}
	fr := createFetchRequestFromBytes(message)
	fmt.Println("fr.topics")
	fmt.Println(fr.topics)
	frr := createFetchResponseFromFetchRequest(fr)

	if frr.correlation_id != 1332264862 {
		t.Errorf("Expected correlation_id to be 1332264862, got %d", frr.correlation_id)
	}
}

func TestHandleFetchRequest(t *testing.T) {
	client, server := net.Pipe()
	//message := []byte{0x00, 0x01, 0x00, 0x10, 0x4f, 0x68, 0xbf, 0x9e, 0x00, 0x09, 0x6b, 0x61, 0x66, 0x6b, 0x61, 0x2d, 0x63, 0x6c, 0x69, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x00, 0x00, 0x00, 0x01, 0x03, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x41, 0x02, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00}
	message := []byte{0x00, 0x01, 0x00, 0x10, 0x70, 0x54, 0x11, 0x5f, 0x00, 0x09, 0x6b, 0x61, 0x66, 0x6b, 0x61, 0x2d, 0x63, 0x6c, 0x69, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x00, 0x00, 0x00, 0x01, 0x03, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00}
	done := make(chan bool)
	go func() {
		handleFetchRequest(server, message)
		done <- true
	}()

	// Write the test request data
	client.Write(message)

	// Read the response
	response := make([]byte, 1024) // Adjust the size as needed
	_, err := client.Read(response)
	if err != nil {
		t.Fatalf("Failed to read response: %v", err)
	}

	// Add assertions here to check the response
	// For example:
	// if n == 0 {
	//     t.Error("Expected non-empty response")
	// }
	// TODO: Add more specific checks based on the expected response

	client.Close()

	// Wait for handleFetchRequest to finish
	select {
	case <-done:
		// Function completed successfully
	case <-time.After(5 * time.Second):
		t.Fatal("handleFetchRequest timed out")
	}

}
